
#include <array>
#include <tuple>

#include "apputils.h"
#include "mesh.h"
#include "qtnn.h"

// По три нормали на вершину!!!
std::vector<vec3> boxTris = {
    { 1.0f, 1.0f, 1.0f },   { -1.0f, 1.0f, 1.0f },  { -1.0f, -1.0f, 1.0f }, { 1.0f, 1.0f, 1.0f },
    { -1.0f, -1.0f, 1.0f }, { 1.0f, -1.0f, 1.0f },  { 1.0f, -1.0f, -1.0f }, { 1.0f, -1.0f, 1.0f },
    { -1.0f, -1.0f, 1.0f }, { 1.0f, -1.0f, -1.0f }, { -1.0f, -1.0f, 1.0f }, { -1.0f, -1.0f, -1.0f },
    { -1.0f, -1.0, -1.0 },  { -1.0f, -1.0, 1.0 },   { -1.0f, 1.0, 1.0 },    { -1.0f, -1.0f, -1.0 },
    { -1.0f, 1.0f, 1.0 },   { -1.0f, 1.0f, -1.0 },  { -1.0f, 1.0f, -1.0f }, { 1.0f, 1.0f, -1.0f },
    { 1.0f, -1.0f, -1.0f }, { -1.0f, 1.0f, -1.0 },  { 1.0f, -1.0f, -1.0 },  { -1.0f, -1.0f, -1.0 },
    { 1.0f, 1.0f, -1.0 },   { 1.0f, 1.0f, 1.0 },    { 1.0f, -1.0f, 1.0 },   { 1.0f, 1.0f, -1.0 },
    { 1.0f, -1.0f, 1.0 },   { 1.0f, -1.0f, -1.0 },  { -1.0f, 1.0f, -1.0f }, { -1.0f, 1.0f, 1.0f },
    { 1.0f, 1.0f, 1.0f },   { -1.0f, 1.0, -1.0f },  { 1.0f, 1.0, 1.0f },    { 1.0f, 1.0, -1.0f }
};

std::vector<vec3> boxNrmls
  = { { 0.0f, 0.0f, 1.0f },  { 0.0f, 0.0f, 1.0f },  { 0.0f, 0.0f, 1.0f },  { 0.0f, 0.0f, 1.0f },
      { 0.0f, 0.0f, 1.0f },  { 0.0f, 0.0f, 1.0f },  { 0.0f, -1.0f, 0.0f }, { 0.0f, -1.0f, 0.0f },
      { 0.0f, -1.0f, 0.0f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, -1.0f, 0.0f },
      { -1.0f, 0.0f, 0.0f }, { -1.0f, 0.0f, 0.0f }, { -1.0f, 0.0f, 0.0f }, { -1.0f, 0.0f, 0.0f },
      { -1.0f, 0.0f, 0.0f }, { -1.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f, -1.0f },
      { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f, -1.0f },
      { 1.0f, 0.0f, 0.0f },  { 1.0f, 0.0f, 0.0f },  { 1.0f, 0.0f, 0.0f },  { 1.0f, 0.0f, 0.0f },
      { 1.0f, 0.0f, 0.0f },  { 1.0f, 0.0f, 0.0f },  { 0.0f, 1.0f, 0.0f },  { 0.0f, 1.0f, 0.0f },
      { 0.0f, 1.0f, 0.0f },  { 0.0f, 1.0f, 0.0f },  { 0.0f, 1.0f, 0.0f },  { 0.0f, 1.0f, 0.0f } };

std::vector<vec3> prismTris
  = { { 0.000000, -0.000000, -1.000000 },     { 0.000000, 0.866025, -0.500000 },
      { 0.750000, -0.433013, -0.500000 },     { 0.000000, 0.866025, -0.500000 },
      { 0.000000, 0.866025, 0.500000 },       { 0.750000, -0.433013, 0.500000 },
      { 0.000000, 0.866025, -0.500000 },      { 0.750000, -0.433013, 0.500000 },
      { 0.750000, -0.433013, -0.500000 },     { 0.000000, 0.866025, 0.500000 },
      { -0.000000, -0.000000, 1.000000 },     { 0.750000, -0.433013, 0.500000 },
      { 0.000000, -0.000000, -1.000000 },     { 0.750000, -0.433013, -0.500000 },
      { -0.750000, -0.433013, -0.500000 },    { 0.750000, -0.433013, -0.500000 },
      { 0.750000, -0.433013, 0.500000 },      { -0.750000, -0.433013, 0.500000 },
      { 0.750000f, -0.433013f, -0.500000f },  { -0.750000f, -0.433013f, 0.500000f },
      { -0.750000f, -0.433013f, -0.500000f }, { 0.750000f, -0.433013f, 0.500000f },
      { -0.000000f, -0.000000f, 1.000000f },  { -0.750000f, -0.433013f, 0.500000f },
      { 0.000000f, -0.000000f, -1.000000f },  { -0.750000f, -0.433013f, -0.500000f },
      { 0.000000f, 0.866025f, -0.500000f },   { -0.750000f, -0.433013f, -0.500000f },
      { -0.750000f, -0.433013f, 0.500000f },  { 0.000000f, 0.866025f, 0.500000f },
      { -0.750000f, -0.433013f, -0.500000f }, { 0.000000f, 0.866025f, 0.500000f },
      { 0.000000f, 0.866025f, -0.500000f },   { -0.750000f, -0.433013f, 0.500000f },
      { -0.000000f, -0.000000f, 1.000000f },  { 0.000000f, 0.866025f, 0.500000f } };

std::vector<vec3> prismNrmls
  = { { 0.654654, 0.377964, -0.654654 },     { 0.654654, 0.377964, -0.654654 },
      { 0.654654, 0.377964, -0.654654 },     { 0.866026, 0.500000, -0.000000 },
      { 0.866026, 0.500000, -0.000000 },     { 0.866026, 0.500000, -0.000000 },
      { 0.866025, 0.500000, 0.000000 },      { 0.866025, 0.500000, 0.000000 },
      { 0.866025, 0.500000, 0.000000 },      { 0.654653, 0.377964, 0.654654 },
      { 0.654653, 0.377964, 0.654654 },      { 0.654653, 0.377964, 0.654654 },
      { -0.000000, -0.755929, -0.654654 },   { -0.000000, -0.755929, -0.654654 },
      { -0.000000, -0.755929, -0.654654 },   { -0.000000, -1.000000, -0.000000 },
      { -0.000000, -1.000000, -0.000000 },   { -0.000000, -1.000000, -0.000000 },
      { -0.000000, -1.000000, 0.000000 },    { -0.000000, -1.000000, 0.000000 },
      { -0.000000, -1.000000, 0.000000 },    { -0.000000f, -0.755929f, 0.654654f },
      { -0.000000f, -0.755929f, 0.654654f }, { -0.000000f, -0.755929f, 0.654654f },
      { -0.654653f, 0.377964f, -0.654654f }, { -0.654653f, 0.377964f, -0.654654f },
      { -0.654653f, 0.377964f, -0.654654f }, { -0.866025f, 0.500000f, 0.000000f },
      { -0.866025f, 0.500000f, 0.000000f },  { -0.866025f, 0.500000f, 0.000000f },
      { -0.866025f, 0.500000f, -0.000000 },  { -0.866025f, 0.500000f, -0.000000 },
      { -0.866025f, 0.500000f, -0.000000 },  { -0.654654f, 0.377964f, 0.654654f },
      { -0.654654f, 0.377964f, 0.654654f },  { -0.654654f, 0.377964f, 0.654654f } };

std::vector<vec3> icosahedrTris
  = { { 0.000000f, 0.000000f, -1.000000f },   { 0.723600f, -0.525720f, -0.447215f },
      { -0.276385f, -0.850640f, -0.447215f }, { 0.723600f, -0.525720f, -0.447215f },
      { 0.000000f, 0.000000f, -1.000000f },   { 0.723600f, 0.525720f, -0.447215f },
      { 0.000000f, 0.000000f, -1.000000f },   { -0.276385f, -0.850640f, -0.447215f },
      { -0.894425f, 0.000000f, -0.447215f },  { 0.000000f, 0.000000f, -1.000000f },
      { -0.894425f, 0.000000f, -0.447215f },  { -0.276385f, 0.850640f, -0.447215f },
      { 0.000000f, 0.000000f, -1.000000f },   { -0.276385f, 0.850640f, -0.447215f },
      { 0.723600f, 0.525720f, -0.447215f },   { 0.723600f, -0.525720f, -0.447215f },
      { 0.723600f, 0.525720f, -0.447215f },   { 0.894425f, 0.000000f, 0.447215f },
      { -0.276385f, -0.850640f, -0.447215f }, { 0.723600f, -0.525720f, -0.447215f },
      { 0.276385f, -0.850640f, 0.447215f },   { -0.894425f, 0.000000f, -0.447215f },
      { -0.276385f, -0.850640f, -0.447215f }, { -0.723600f, -0.525720f, 0.447215f },
      { -0.276385f, 0.850640f, -0.447215f },  { -0.894425f, 0.000000f, -0.447215f },
      { -0.723600f, 0.525720f, 0.447215f },   { 0.723600f, 0.525720f, -0.447215f },
      { -0.276385f, 0.850640f, -0.447215f },  { 0.276385f, 0.850640f, 0.447215f },
      { 0.723600f, -0.525720f, -0.447215f },  { 0.894425f, 0.000000f, 0.447215f },
      { 0.276385f, -0.850640f, 0.447215f },   { -0.276385f, -0.850640f, -0.447215f },
      { 0.276385f, -0.850640f, 0.447215f },   { -0.723600f, -0.525720f, 0.447215f },
      { -0.894425f, 0.000000f, -0.447215f },  { -0.723600f, -0.525720f, 0.447215f },
      { -0.723600f, 0.525720f, 0.447215f },   { -0.276385f, 0.850640f, -0.447215f },
      { -0.723600f, 0.525720f, 0.447215f },   { 0.276385f, 0.850640f, 0.447215f },
      { 0.723600f, 0.525720f, -0.447215f },   { 0.276385f, 0.850640f, 0.447215f },
      { 0.894425f, 0.000000f, 0.447215f },    { 0.276385f, -0.850640f, 0.447215f },
      { 0.894425f, 0.000000f, 0.447215f },    { 0.000000f, 0.000000f, 1.000000f },
      { -0.723600f, -0.525720f, 0.447215f },  { 0.276385f, -0.850640f, 0.447215f },
      { 0.000000f, 0.000000f, 1.000000f },    { -0.723600f, 0.525720f, 0.447215f },
      { -0.723600f, -0.525720f, 0.447215f },  { 0.000000f, 0.000000f, 1.000000f },
      { 0.276385f, 0.850640f, 0.447215f },    { -0.723600f, 0.525720f, 0.447215f },
      { 0.000000f, 0.000000f, 1.000000f },    { 0.894425f, 0.000000f, 0.447215f },
      { 0.276385f, 0.850640f, 0.447215f },    { 0.000000f, 0.000000f, 1.000000f } };

std::vector<vec3> icosahedrNrmls
  = { { 0.187597f, -0.577354f, -0.794651 },   { 0.187597f, -0.577354f, -0.794651 },
      { 0.187597f, -0.577354f, -0.794651 },   { 0.607065f, 0.000000f, -0.794652f },
      { 0.607065f, 0.000000f, -0.794652f },   { 0.607065f, 0.000000f, -0.794652f },
      { -0.491122f, -0.356829f, -0.794652f }, { -0.491122f, -0.356829f, -0.794652f },
      { -0.491122f, -0.356829f, -0.794652f }, { -0.491122f, 0.356829f, -0.794652f },
      { -0.491122f, 0.356829f, -0.794652f },  { -0.491122f, 0.356829f, -0.794652f },
      { 0.187597f, 0.577354f, -0.794651f },   { 0.187597f, 0.577354f, -0.794651f },
      { 0.187597f, 0.577354f, -0.794651f },   { 0.982246f, 0.000000f, -0.187597f },
      { 0.982246f, 0.000000f, -0.187597f },   { 0.982246f, 0.000000f, -0.187597f },
      { 0.303536f, -0.934171f, -0.187589f },  { 0.303536f, -0.934171f, -0.187589f },
      { 0.303536f, -0.934171f, -0.187589f },  { -0.794649f, -0.577359f, -0.187587f },
      { -0.794649f, -0.577359f, -0.187587f }, { -0.794649f, -0.577359f, -0.187587f },
      { -0.794649f, 0.577359f, -0.187587f },  { -0.794649f, 0.577359f, -0.187587f },
      { -0.794649f, 0.577359f, -0.187587f },  { 0.303536f, 0.934171f, -0.187589f },
      { 0.303536f, 0.934171f, -0.187589f },   { 0.303536f, 0.934171f, -0.187589f },
      { 0.794649f, -0.577359f, 0.187587f },   { 0.794649f, -0.577359f, 0.187587f },
      { 0.794649f, -0.577359f, 0.187587f },   { -0.303536f, -0.934171f, 0.187589f },
      { -0.303536f, -0.934171f, 0.187589f },  { -0.303536f, -0.934171f, 0.187589f },
      { -0.982246f, 0.000000f, 0.187597f },   { -0.982246f, 0.000000f, 0.187597f },
      { -0.982246f, 0.000000f, 0.187597f },   { -0.303536f, 0.934171f, 0.187589f },
      { -0.303536f, 0.934171f, 0.187589f },   { -0.303536f, 0.934171f, 0.187589f },
      { 0.794649, 0.577359f, 0.187587f },     { 0.794649, 0.577359f, 0.187587f },
      { 0.794649, 0.577359f, 0.187587f },     { 0.491122f, -0.356829f, 0.794652f },
      { 0.491122f, -0.356829f, 0.794652f },   { 0.491122f, -0.356829f, 0.794652f },
      { -0.187596f, -0.577354f, 0.794651f },  { -0.187596f, -0.577354f, 0.794651f },
      { -0.187596f, -0.577354f, 0.794651f },  { -0.607065f, 0.000000f, 0.794652f },
      { -0.607065f, 0.000000f, 0.794652f },   { -0.607065f, 0.000000f, 0.794652f },
      { -0.187597f, 0.577354f, 0.794651f },   { -0.187597f, 0.577354f, 0.794651f },
      { -0.187597f, 0.577354f, 0.794651f },   { 0.491122f, 0.356829f, 0.794652f },
      { 0.491122f, 0.356829f, 0.794652f },    { 0.491122f, 0.356829f, 0.794652f } };

BasicBody::BasicBody(int type) {
    m_bodyYaw = m_bodyPitch = m_bodyRoll = 0.0f;
    m_bodyOffset = vec3();

    switch (type) {
    case BasicBody::ICOSAHEDRON:
        BodyTriangles = icosahedrTris;
        BodyNormals = icosahedrNrmls;
        break;

    case BasicBody::BOX:
        BodyTriangles = boxTris;
        BodyNormals = boxNrmls;
        break;

    case BasicBody::PRISM:
        BodyTriangles = prismTris;
        BodyNormals = prismNrmls;
        break;
    }
}

BasicBody::BasicBody(int type, vec3 scl) {
    m_bodyYaw = m_bodyPitch = m_bodyRoll = 0.0f;
    m_bodyOffset = vec3();

    switch (type) {
    case BasicBody::ICOSAHEDRON:
        BodyTriangles = icosahedrTris;
        BodyNormals = icosahedrNrmls;
        break;

    case BasicBody::BOX:
        BodyTriangles = boxTris;
        BodyNormals = boxNrmls;
        break;

    case BasicBody::PRISM:
        BodyTriangles = prismTris;
        BodyNormals = prismNrmls;
        break;
    }

    mtrx4 scaleMtrx = mtrx4FromScale(scl);
    for (auto &vert : BodyTriangles) {
        vert = mtrx4MultVec3(scaleMtrx, vert);
    }

    // glGenBuffers(1, &m_oglBuffer);
    // glBindBuffer(GL_ARRAY_BUFFER, m_oglBuffer);
    // glBufferData(GL_ARRAY_BUFFER, BodyTriangles.size()*3, 0, GL_STATIC_DRAW); // reserve space
}

BasicBody::~BasicBody() {
    // glDeleteBuffers(1, &m_oglBuffer);
}

void BasicBody::updateAndDraw() {
    mtrx4 mRotate = mtrx4FromEuler(m_bodyYaw, m_bodyPitch, m_bodyRoll);
    mtrx4 mOffset = mtrx4FromOffset(m_bodyOffset);

    mtrx4 mAffine = mRotate * mOffset;

    // Прямая транформация в нужное место и с нужным поворотом
    for (size_t i = 0; i < BodyTriangles.size() / 3; i++) {
        BodyTriangles[i * 3 + 0] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 0]);
        BodyTriangles[i * 3 + 1] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 1]);
        BodyTriangles[i * 3 + 2] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 2]);

        BodyNormals[i * 3 + 0] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 0]);
        BodyNormals[i * 3 + 1] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 1]);
        BodyNormals[i * 3 + 2] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 2]);
    }

    glColor3f(0.3f, 0.6f, 1.0f);
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3, GL_FLOAT, 0, BodyTriangles.data());
    glNormalPointer(GL_FLOAT, 0, BodyNormals.data());
    glDrawArrays(GL_TRIANGLES, 0, BodyTriangles.size());
    glDisableClientState(GL_NORMAL_ARRAY);
    glDisableClientState(GL_VERTEX_ARRAY);

    mAffine.invertSelf();
    mRotate.invertSelf();

    // Обратная трансформация
    for (size_t i = 0; i < BodyTriangles.size() / 3; i++) {
        BodyTriangles[i * 3 + 0] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 0]);
        BodyTriangles[i * 3 + 1] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 1]);
        BodyTriangles[i * 3 + 2] = mtrx4MultVec3(mAffine, BodyTriangles[i * 3 + 2]);

        BodyNormals[i * 3 + 0] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 0]);
        BodyNormals[i * 3 + 1] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 1]);
        BodyNormals[i * 3 + 2] = mtrx4MultVec3(mRotate, BodyNormals[i * 3 + 2]);
    }
}

void BasicBody::setOrientation(float yaw, float pitch, float roll) {
    m_bodyYaw = yaw;
    m_bodyPitch = pitch;
    m_bodyRoll = roll;
}

void BasicBody::setOffset(vec3 offst) {
    m_bodyOffset = offst;
}

void BasicBody::bodyMove(vec3 offst) {
    m_bodyOffset = vec3Sum(m_bodyOffset, offst);
}

void BasicBody::bodyRotate(float yaw, float pitch, float roll) {
    m_bodyYaw += yaw;
    m_bodyPitch += pitch;
    m_bodyRoll += roll;
}
